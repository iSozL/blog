---
title: JavaScript：混合对象类
date: 2019-07-06 10:08:23
tags: 笔记|JavaScript
categories: 笔记|JavaScript
---
---
JavaScript的“类”
---

JavaScript当中有一些近似类的语法元素（new,instanceof等）,后来es6增加了class等关键字。但这并不意味着JavaScript有类,实际上并没有,只是为了满足对于类的设计模式的普遍需求,它提供了一些近似类的语法而已。

---
构造函数
---

类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，称为构造函数

---
显式混入
---

{% codeblock %}
function mixin (sourceObj, targetObj) {
    for (var key in sourceObj) {
      if (!key in targetObj)
        targetObj[key] = sourceObj[key]
    }
    return targetObj
  }
  var Vehicle = {
    engines: 1,
    ignition: function () {
      console.log("turning on my engine")
    },
    drive: function () {
      console.log("steeling and moving forward")
    }
  };
  var Car = mixin(Vehicle, {
    wheels: 4,
    drive: function () {
      Vehicle.drive.call(this);
      console.log(`rolling on all ${this.wheels} wheels`)
    }
  });
  Car.drive()  // steeling and moving forward,rolling on all 4 wheels
{% endcodeblock %}
现在Car有一份Vehicle属性和函数的副本，函数并不是复制,而是函数的引用,Vehile.drive.call(this)就是所说的显式多态。因为js中没有相对多态的机制,而Car和Vehile中都有drive()函数,为了指明调用对象,我们必须使用绝对引用,如果直接引用Vehile.drive,this会绑定到Vehile对象,所以我们使用.call(this)来保证drive()在car对象的作用域中执行。

---
隐式混入
---

{% codeblock %}
  var Something = {
    cool: function () {
      this.greeting = "hello"
      this.count = this.count ? this.count + 1 : 1
    }
  }
  Something.cool()
  console.log(Something.greeting) // hello
  console.log(Something.count) // 1
  var Another = {
    cool: function () {
      Something.cool.call(this)
    }
  }
  Another.cool()
  console.log(Another.greeting) // hello
  console.log(Another.count) // 1
{% endcodeblock %}
利用this的重新绑定功能,但是Something.cool.call(this)仍然无法变成相对引用,所以使用的时候要小心,通常来说,尽量避免这样使用的结构,以保证代码的整洁和可维护性
