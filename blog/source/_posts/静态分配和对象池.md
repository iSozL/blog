---
title: 静态分配和对象池
date: 2020-06-30 10:40:19
tags: JavaScript
categories: JavaScript
---

# 静态分配和对象池

### "压榨"出更高的性能

​	在JavaScript性能上，你可能会想在浏览器中挤出最后一点性能，说到浏览器，就不得不提到垃圾回收机制，而达到这个目的的一个方法就是将浏览器垃圾回收机制运行的次数最小化，但是这个时候问题又来了，垃圾回收机制是不能直接被我们所控制的，这样，我们就只能换一个角度去优化，比如，围绕浏览器调度垃圾回收的方法进行优化，理论上，如果你能在负责任的进行内存分配的同时避免多余的垃圾回收，你就能获得很好的性能收益。

### 对象的"流失率"（the rate of object churn）

​	浏览器运行垃圾回收机制的一个重要因素就是对象的流失率，如果大量的对象正在被实例化，并且马上就要退出作用域，这个时候对象的流失率就高，导致浏览器会更加频繁的运行垃圾回收机制，这样会导致浏览器的运行速度减缓。如下面这个例子：

```javascript
functio addVector(a, b) {
    let resultant = new Vector();
    resultant.x = a.x + b.x;
    resultant.y = a.y + b.y;
    return resultant;
}
```

当调用这个函数的时候，会在堆中创建一个新的实例化对象，并且修改它的属性，然后再返回修改后的对象，可以看出，resultant对象的生存周期非常的短暂，它很快就会有资格进行垃圾收集，如果addVector函数经常被调用的话，垃圾收集器就会注意到它非常高的对象流失率，垃圾回收就会更加频繁的运作，这样就会导致浏览器性能就会差很多。

### 避免垃圾回收器的关注

​	上面这个函数中动态创建了新的对象，假如我们修改这个函数，让它去使用一个已经存在的向量对象：

```javascript
function addVector(a, b , resultant) {
    resultant.x = a.x + b.x;
    resultant.y = a.y + b.y;
    return resultant;
}
```

可以看出这个函数新加了向量参数，并且在其它的地方实例化，但是函数的行为并没有发生变化，那我们应该在哪里创建这个resultant对象同时避免垃圾回收器的关注呢？解决这个问题的一种策略就是使用对象池。那么什么又是对象池呢？

### 对象池

​	简单来说，就是对象池中会包含若干提前准备好的实例，当需要它的时候就从对象池中提取，当不需要时，则重新放入对象池。

#### 对象池的优点：

- 使用对象池不需要频繁的产生和销毁实例对象。
- 对象池中的实例如果不够程序调用才会继续产生实例，大大节省了性能。

------

​	在初始化的某一个时刻，会创建一个对象池，管理一个可回收对象的集合，应用程序可以在对象池中请求一个对象，设置它的属性，使用它，并在使用结束的时候返回给对象池，因为对象池不需要频繁的将对象实例化，所以垃圾回收算法很难注意到小幅度对象流失率，因此垃圾回收运行的次数就会更少。对象池的伪实现看起来如下:

```javascript
// vectorPool是一个已经存在的对象池
let v1 = vectorPool.allocate();
let v2 = vectorPool.allocate();
let v3 = vectorPool.allocate();

v1.x = 10;
v1.y = 5;
v2.x = -3;
v2.y = -6;

addVector(v1, v2, v3);

console.log([v3.x, v3.y]); // [7, -1]

vectorPool.free([v1, v2, v3]);

// 如果这些对象有属性引用了其他对象,他们需要被设置为null
v1 = null;
v2 = null;
v3 = null;
```

如果对象池仅仅只要在必要的时候分配向量对象(如果不存在就创建一个新的，如果存在就使用当前存在的)，本质上是一个贪心算法，具有单调递增性，但是静态储存，它必须要由一些结构去维护这个集合，一个好多选择就是数组，然而必须要小心谨慎的设计使用数组实现，不然会产生多余的垃圾收集，因为在JavaScript中，数组是动态分配的，如下面这个例子:

```
let vectorList = new Array(100);
let vector = new Vector();
vectorList.push(vector);
```

引擎会删除这个100大小的数组并且创建一个200大小的新数组，垃圾收集器就会注意到这个删除并且会因为它而运行的更快，这种动态分配可以通过在数组初始化时创建一个合适大小的数组来避免，这样就能避免重新分配数组大小的操作，但是你需要提前知道这个数组到底有多大。

### 写在结尾

静态分配是一种非常极端的优化方式，当你在受到浏览器垃圾回收性能阻碍的时候，它能帮助你产生性能的增益，但是这种情况非常的罕见，在更多的情况下，这是一种过早的优化，是🙅‍合适的。

### 参考资料

- profession JavaScript for web developors, 4th editor