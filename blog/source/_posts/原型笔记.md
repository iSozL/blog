---
title: JavaScript：原型
date: 2019-07-06 16:37:21
tags: 笔记|JavaScript
categories: 笔记|JavaScript
---
---
属性设置和屏蔽
---

{% codeblock %}
myObject = "foo"
{% endcodeblock %}
大多数开发者认为如果向[[prototype]]链子上层已经存在的属性赋值，就一定会发生屏蔽，实际上有三种情况
{% blockquote %}
1.如果在[[prototype]]链上层存在名为foo的普通属性并且没有被标记为只读，那就直接会在对象上添加一个名为foo的属性，它就是屏蔽属性
2.如果在[[prototype]]链上层存在foo但是它被标记为只读，那么无法修改该属性，在严格模式下运行会出错，但是在普通模式下会被忽略，不会发生屏蔽
3.如果在[[prototype]]链上层存在foo，并且它是一个setter，那就会调用这个setter。foo不会添加到myObject上，也不会重写setter
{% endblockquote %}
如果你希望第二条和第三条这样的情况也发生屏蔽，你可以用Object.defineProperty来替代 = 

有些情况下会产生隐式屏蔽
{% codeblock %}
var obj1 = {
    a: 2
  }
  var obj2 = Object.create(obj1)
  console.log(obj1.a) // 2
  console.log(obj2.a) // 2
  obj2.a ++ // 发生隐式屏蔽,obj2.a ++ 相当于 obj2.a = obj2.a + 1
  console.log(obj1.a) // 2
  console.log(obj2.a) // 3
{% endcodeblock %}

---
继承
---

关联对象两个错误的做法
1.Bar.prototype = Foo.prototype
它只是让Bar.prototype直接引用Foo.prototype对象，当你执行类似Bar.prototype.xxx = ...的操作时，会直接修改Foo.prototype对象本身
2.Bar.prototype = new Foo()
这的确创建了一个新的对象关联到Bar.prototype。但是这使用了函数构造调用，如果函数Foo有一些副作用，就会影响到后代，后果不堪设想

因此要创建一个合适的关联对象，必须使用Object.creat()，而不是使用具有副作用的Foo(..)，这样做的唯一缺点就是需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象


